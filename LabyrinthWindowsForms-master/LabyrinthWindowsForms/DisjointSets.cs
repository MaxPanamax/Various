using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Ponomarenko_Labyrinth_WF
{
    /// <краткое содержание>
    /// /// Класс непересекающихся множеств
    /// 
    /// КОНСТРУКЦИЯ: с int, представляющим начальное количество наборов
    /// 
    /// ****************** ОБЩЕСТВЕННЫЕ ОПЕРАЦИИ*********************
    /// недействительное объединение( root1, root2 ) --> Объединить два набора
    /// int find( x ) --> Возвращает набор, содержащий x
    /// ****************** ОШИБКИ********************************
    /// Выполняется проверка параметров на ошибки
    /// 
    /// Непересекающийся класс набора, используя объединение по рангу
    /// и сжатие пути.
    /// Элементы в наборе нумеруются, начиная с 0.
    // Преобразование / C#:
    /// Изменен массив .длина до c# .Длина
    /// Добавлены дополнительные комментарии.
    /// 
    /// @автор: Пономаренко Максим 
    /// @версия: 1
    /// @дата: 2022-10-30
    /// </краткое содержание>
    public class DisjointSets
	{
        /// <краткое содержание>
        /// Конструктор для объекта непересекающихся множеств.
        /// </краткое содержание>
        /// <param name="numElements">начальное количество непересекающихся множеств</param>

        public DisjointSets(int numElements)
		{
			s = new int[numElements];
			for (int i = 0; i < s.Length; i++)
				s[i] = -1;
		}
        /// <краткое содержание>
        /// Union выполняет операцию объединения для двух непересекающихся множеств, используя эвристику высоты.
        /// root1 и root2 различны и представляют собой имена наборов.
        /// /// Выдает исключение ArgumentException, если room1 или room2 не являются отдельными корнями.
        /// </краткое содержание>
        /// <param name="root1">отдельное имя набора</param>
        /// <param name="root2">другое отличное имя набора</param>

        public void Union(int root1, int root2)
		{
			AssertIsRoot(root1);
			AssertIsRoot(root2);
			if (root1 == root2)
				throw new ArgumentException("Союз: root1 == root2 " + root1);

			if (s[root2] < s[root1]) // root2 глубже
                s[root1] = root2;        // Создать новый корень root2
            else
			{
				if (s[root1] == s[root2])
					s[root1]--;          // Обновить высоту, если та же
                s[root2] = root1;        // Создать новый корень root1
            }
		}
        /// <краткое содержание>
        /// Выполните поиск со сжатием пути.
        /// Find рекурсивно вызывает сам себя, чтобы найти x.
        /// Выдает исключение ArgumentException, если x недействителен (через AssertIsItem).
        /// </краткое содержание>
        /// <param name="x">искомый элемент</param>
        /// <returns>набор, содержащий x</returns>

        public int Find(int x)
		{
			AssertIsItem(x);
			if (s[x] < 0)
				return x;
			else
				return s[x] = Find(s[x]);
		}

		private int[] s;
        /// <краткое содержание>
        /// AssertIsRoot сначала вызывает AssertIsItem, чтобы убедиться, что параметр inparameter 'root'
        /// существует как непересекающийся набор, а затем проверяет, что он на самом деле является корнем. 
        /// Выдает исключение ArgumentException, если 'root' не является элементом (через AssertIsItem)
        /// /// аргумент, за исключением того, что это элемент, но не корень.
        /// </краткое содержание>
        ///<param name="root"> целое число для проверки на предмет того,
        ///что оно является элементом и корнем</param>

        private void AssertIsRoot(int root)
		{
			AssertIsItem(root);
			if (s[root] >= 0)
				throw new ArgumentException("Союз: " + root + " не корень");
		}
        /// <краткое содержание>
        /// AssertIsItem проверяет, существует ли элемент в непересекающемся наборе и является
        /// следовательно, действительный элемент внутри него.
        /// Выдает исключение ArgumentException, если 'x' не является допустимым элементом.
        /// </краткое содержание>
        /// <param name="x">целое число для проверки на предмет того, что оно является элементом</param>
        private void AssertIsItem(int x)
		{
			if (x < 0 || x >= s.Length)
				throw new ArgumentException("Непересекающиеся множества: " + x + " не предмет");
		}
	}
}
